<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Journal Viewer</title>
  <style>
    body { margin:0; overflow:hidden; background:#f0f0f0 }
    canvas { display:block }
  </style>
</head>
<body>
  <canvas id="cv"></canvas>
  <script>
    const canvas = document.getElementById('cv');
    const ctx    = canvas.getContext('2d');
    const dpr    = window.devicePixelRatio || 1;

    // camera state
    const cam = { x: 0, y: 0, scale: 1 };

    // cache images by their base64 string
    const imgCache = {};

    let data, sceneW, sceneH;

    // resize for retina and redraw
    function resize() {
      canvas.width  = window.innerWidth  * dpr;
      canvas.height = window.innerHeight * dpr;
      canvas.style.width  = window.innerWidth  + 'px';
      canvas.style.height = window.innerHeight + 'px';
      // reset transform so drawing commands map to CSS pixels
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      draw();
    }
    window.addEventListener('resize', resize);

    // load your JOURNAL.jrn
    async function load() {
      try {
        const resp = await fetch('JOURNAL.jrn');
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        data = await resp.json();
        // scene dimensions
        sceneW = data.width  || 10000;
        sceneH = data.height || 10000;
        // center & fit
        cam.scale = Math.min(window.innerWidth/sceneW, window.innerHeight/sceneH);
        cam.x = -sceneW/2;
        cam.y = -sceneH/2;
        resize();
      } catch (err) {
        console.error(err);
        ctx.fillStyle = '#fee';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#900';
        ctx.font = '20px sans-serif';
        ctx.fillText('Failed to load JOURNAL.jrn', 10, 30);
      }
    }
    load();

    // pan
    let dragging = false, lastX=0, lastY=0;
    canvas.addEventListener('mousedown', e => {
      dragging = true;
      lastX = e.clientX; lastY = e.clientY;
    });
    window.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mousemove', e => {
      if (!dragging) return;
      const dx = (e.clientX - lastX)/cam.scale;
      const dy = (e.clientY - lastY)/cam.scale;
      cam.x += dx; cam.y += dy;
      lastX = e.clientX; lastY = e.clientY;
      draw();
    });

    // zoom
    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      // mouse in world coords
      const mx = (e.clientX - rect.left)/cam.scale - cam.x;
      const my = (e.clientY - rect.top )/cam.scale - cam.y;
      const factor = Math.exp(-e.deltaY * 0.001);
      cam.scale *= factor;
      // keep point under cursor fixed
      cam.x = (e.clientX - rect.left)/cam.scale - mx;
      cam.y = (e.clientY - rect.top )/cam.scale - my;
      draw();
    }, { passive: false });

    function draw() {
      if (!data) return;
      // clear
      ctx.fillStyle = data.background || '#fff';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // set up camera
      ctx.save();
      // center to canvas middle
      ctx.translate(canvas.width/(2*dpr), canvas.height/(2*dpr));
      ctx.scale(cam.scale, cam.scale);
      ctx.translate(cam.x, cam.y);

      // render items in order
      for (const itm of data.items) {
        if (itm.type === 'image') {
          const key = itm.b64;
          let img = imgCache[key];
          if (!img) {
            img = new Image();
            img.src = 'data:image/png;base64,' + key;
            img.onload = draw;  // redraw once loaded
            imgCache[key] = img;
          }
          if (img.complete) {
            const s = itm.scale || 1;
            ctx.drawImage(img, itm.x, itm.y, img.width * s, img.height * s);
          }
        }
        else if (itm.type === 'text') {
          ctx.fillStyle = '#000';
          ctx.font = '16px Courier New';
          // y+16 so text baseline matches your original
          ctx.fillText(itm.text, itm.x, itm.y + 16);
        }
      }

      ctx.restore();
    }
  </script>
</body>
</html>
